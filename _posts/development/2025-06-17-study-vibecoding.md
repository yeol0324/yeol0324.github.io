---
layout: post
title: "AI 더 똑똑하게 사용하기"
date: 2025-06-17 22:01:24 +09:00
summary: "성공적인 바이브 코딩을 위한 지침!"
categories: development
tags: 바이브코딩 vibecoding ai cursor chatgpt
---


여러분은 AI를 활용해서 문제를 해결해보신 적이 있으신가요? 저는 실무에서도 AI를 자주 활용하곤 했었는데 원하는 것만큼 결과물이 나오지 않을 때가 더 많았습니다. 어떻게 하면 잘 사용할 수 있을까 고민을 하던 중, 원티드에서 개설한 [실무에진짜통하는 AI활용력, 바이브코딩마스터] 강의를 듣게 되었습니다. ✏️ 총 4개의 강의를 듣고 공부한 내용을 정리해보려 합니다.

## 바이브 코딩(Vibe Coding)

> 개발자는 자신이 만들고자 하는 것의 전반적인 방향 또는 "바이브"를 전달하고, AI 시스템은 이러한 의도를 기능적인 코드로 변환합니다.

개발자가 생성형 인공지능의 도움을 받아 코드를 작성하는 행위를 일컫는 신조어로 프로그래밍을 할 때 사전에 엄밀한 논리나 설계를 바탕으로 하지 않고 직감과 느낌에 의존한다는 의미로 '바이브'코딩이라는 이름이 붙었습니다.

## 바이브 코딩 장점과 단점

“와 알아서 다 해주네? 이 어려운걸 5분만에?” 한번이라도 사용해봤다면 아실 거예요. 개발 속도가 엄청 빠릅니다. 사람이랑 절대 비교할 수 없을 정도로 금방 결과물이 나옵니다. 그래서 개발을 잘 모르는 분들도 쉽게 접근할 수 있는 장점이 있습니다.

하지만 AI한테 단순한 코딩만 맡긴 게 아니고 조금이라도 큰 과제를 내주었다면 알 수 있을거예요. 코드 품질이 낮고 프롬프트를 구체적으로 작성해도 잘 이해하지 못합니다. 심지어 여러번 실행하면 실행할때마다 다른 결과를 만들어서 컨트롤이 어렵습니다. 그래서 프로토타입 개발용, 협업 및 큰 프로젝트에서는 활용이 어렵다 라는 부정적인 의견도 많습니다. 

저도 처음 사용할 땐 부정적인 편이었습니다. 명령 몇 줄이면 다 만들어준다는 말에 실행도 잘 안 되고 이상하게 만들어줄것 같은 생각에 단순하고 반복되는 작업만 시키다가 점점 신뢰를 하게 됐던 것 같습니다. 점차 많은 양을 한번에 맡기면서 컨트롤도 안 되고 대충 확인만하고 실행 안 된다고 짜증만 났던 적도 있습니다. 그리고나서는 엄청나게 간단한 문법도 검색하고 있는 저를 발견하고 정신차리게 된 적도 있어요.

## 더닝 크루거 효과

이런 반응은 왜 나올까요? [더닝 크루거 효과](http://docs.vibe-coding-framework.com/dunning-kruger-effect) 라는 게 있습니다.

> 더닝-크루거 효과는 AI 지원 개발에서 초보자가 자신의 역량을 과대평가해 취약점이나 오류가 있는 코드를 그대로 신뢰하게 만드는 위험을 낳는다. 반대로 숙련된 개발자는 잠재적 문제를 예리하게 인지하는 탓에 AI의 기여 자체를 과소평가하며 활용을 꺼리기도 한다. 이처럼 경험 수준에 따라 AI 코드에 대한 신뢰도가 크게 달라져 팀 내 인식 차이가 발생한다. 특히 초보자가 AI에 지나치게 의존하면 점차 비판적 사고 능력이 약화되며, 자신감과 실제 역량 사이의 격차가 더욱 커지는 악순환이 생긴다.


이를 막기 위해 Vibe 프로그래밍은 검증 절차와 지식 보존 체계를 마련해 개발자가 AI 코드를 현실적으로 평가하며 전문성을 키울 수 있도록 합니다. AI로 코딩을 하는 것이 아닌 AI를 활용하는 것입니다.

## **1. AI 그냥 말고 잘 쓰기**

1. 나를 서포트 해 주는 TOOL 로 활용하기
2. 의존하지 않고 통제하기
3. 내가 먼저 전문가가 되기
4. 새로운 소식에 관심 갖기

## MCP

**MCP(Model Context Protocol)**란 인공지능 모델, 특히 LLM(대규모 언어 모델)이 다양한 외부 도구 및 시스템과 효율적으로 소통할 수 있도록 설계된 개방형 표준 프로토콜입니다.

AI가 웹 검색, 계산, API 호출 등 현실 세계의 작업을 수행할 수 있도록 돕는 일종의 "소통 언어" 역할을 합니다. 이를 통해 AI 에이전트는 복잡한 작업을 자동화하고 더 지능적인 행동을 구현할 수 있습니다.

mcp에 대해서는 더 자세히 알아보고 싶어서 간략한 소개만 하고 넘어갈게요. 그치만 오늘 제일 중요한 개념이에요! 이번 강의에서는 MCP 사용 유무를 체감 해봤습니다.

## Cursor 

강의에서는 [커서 AI Editor](https://www.cursor.com)로 진행됐습니다.

강의 시작 전에 미리 손에 익혀두기 위해 맛보기로 사용해봤는데, 기대보다 더 똑똑하고 사용하기 편했습니다! 초기 셋팅도 커서가 도와주고, vscode 셋팅도 자동으로 불러와지고, 특히 간단한 반복작업할 때 신세계였습니다. ~왜 안 써?~ 저는 지금 오프라인 환경에서 업무 진행 중이어서 사용하지 못하지만 실무에서 잘쓰면 정말 활용도가 좋을 것 같습니다.

- cursor mcp 셋팅

```
Cursor Setting > Tools&Integrations > MCP Tools > New MCP Server
```

### context 7

강의에서 [context7](https://github.com/upstash/context7) 이라는 mcp를 사용했습니다. 

 * MCP: AI가 외부와 소통하는 표준화된 '조사 사용 규칙'
 * Context7: 그 규칙을 이용해 '개발 문서'라는 특정 분야의 조사를 능숙하게 활용하여 AI에게 정확한 맥락을 제공하는 서비스


사이트에 접속하여 [install in Cursor] 탭을 열어서 json을 복붙하기 💾 그 다음 New MCP Server에 json을 붙여넣기, 저장을 하고 나면 MCP 리스트에 enabled 2 라고 실행되면 정상입니다!

```json
{
  "mcpServers": {
    "context7": {
      "command": "npx",
      "args": ["-y", "@upstash/context7-mcp"]
    }
  }
}
```

## cursor Chat

커서의 핵심 기능인 Chat을 사용해보겠습니다. ctrl+i 또는 cmd+i로 활성화를 해서 프롬프트를 입력하면 커서가 자동으로 파일 생성, 작성까지 다 해줘요.

💬 평소처럼 막 요청해 보기
- 사용자가 원하는 상품의 최저가를 인터넷에서 찾아서 가격과 구매사이트 링크를 리스트업해서 보여주는 Agent 를 개발 해줘,
- 심플하게 Streamlit으로 개발하고 llm 모델은 gemini 사용해줘

💬 MCP를 사용해서 요청해 보기 
- 사용자가 원하는 상품의 최저가를 인터넷에서 찾아서 가격과 구매사이트 링크를 리스트업해서 보여주는 Agent 를 개발 해줘
- 심플하게 Streamlit으로 개발하고 llm 모델은 gemini 사용해줘
- mcp context7 참고해서 개발해줘

ai를 활용한 실습으로 정말 다양한 결과물이 나왔는데요 저는 한번도 성공하지 못했씁니다. env 파일까지 다 만들어 줬다는 분도 계시고, 차트를 만들어서 비교까지 해줬다는 분도 계셨는데 저는 한번도 검색 결과가 나온 적이 없어요... 😂 성공할 때까지 또 만들어 보려고 합니다.

결과가 나오면 cursor가 실행하라는 방법대로 실행하고 발생하는 오류를 그대로 cursor한테 보내서 ”해결해줘. “  방식으로 진행하시면 됩니다.

*번외*
제미나이 모델을 사용하므로 제미나이 키를 발급받아야하는데요 사용할 때 모델은 얘를 사용했습니다.

• gemini-2.5-flash-preview-05-20


## 운에 기대지 않는 코딩

이번 강의 중에 가장 웃픈 문장이었습니다. 사용하다보면 이번엔 진짜다. 이번엔 진짜 진짜다 마지막 기회다. 하면서 사용했던 경험이 떠올랐어요. 이번 강의를 듣고 AI를 더 잘 활용하고 운에 기대지 않는 코딩을 하게 되었으면 좋겠습니다. 😵


이번 강의 내 결과물
![](/assets/images/20250617/image.png)


## **2. 프롬프트 엔지니어링**

이전 강의에서 AI에 막연한 지시를 내리면 프로젝트가 산으로 간다는 것을 경험했습니다. 이번에는 AI를 효과적으로 통제하며 사용하는 방법을 순서대로 알아봅시다. 핵심은 **프롬프트 엔지니어링**을 이해하고 AI와 '대화'하듯 소통하는 것입니다. AI와 효과적으로 협업하는 프롬프트 엔지니어링 전략을 생각해봅시다

## 프롬프트

프롬프트를 아무리 입력해도 원하는 결과가 나오지 않는 경우가 있습니다. 심지어 시키지 않은 내용도 들어가있는 경우가 많죠! AI한테 지시를 내릴 때 입력하는 텍스트 외에도 많은 프롬프트가 자동으로 추가되기 때문입니다. 그렇기때문에 프롬프트는 최대한 간결하게 유지하여 명확한 의도를 전달해야 합니다.

**프롬프트 구성 요소**

  * **System Prompt** AI의 기본적인 역할과 지시 정의
  * **Context (Global Rule)** 전역적으로 적용되는 규칙이나 배경 정보
  * **Project Rules (cursor/rules)** 프로젝트별로 설정된 규칙
  * **Codebase Context** 현재 작업 중인 코드와 관련된 정보들
  * **Memory** 이전 대화 내용을 기반으로 유지하는 컨텍스트
  * **User Prompt** 사용자가 AI에게 직접 전달하는 지시 



### 시스템 프롬프트 엿보기

LLM은 학습된 패턴과 지시를 기반으로 작동합니다. 그래서 ! 특정 프롬프트를 통해 시스템 프롬프트를 엿볼 수 있습니다. 예를 들어, ChatGPT에 
특정 문장을 보내면 시스템 프롬프트의 일부를 확인할 수 있습니다.

![](/assets/images/20250619/chatgpt.png)


### 프롬프트 엔지니어링 핵심 

효과적인 프롬프트 작성을 위한 핵심을 알아볼까요? LLM을 다룰 때 참고해서 더욱 내 말을 더 잘 알아듣고 일을 잘하는 일잘꾼으로 만들어봅시다.

**1. AI에게 수행할 작업을 명확하게 전달**<br>
 - 텍스트 요약해줘, 자료 정리해줘<br>

**2. 문제 해결에 필요한 관련 정보를 제공** <br>
 - react 19 사용 중인데 useOptimistic 사용해서 적용해줘<br>

**3. 핵심만 남기고 불필요한 설명은 제거**<br>

**4. 원하는 출력 형태를 명시**<br>
 - 정리한 자료를 표로 만들어 줘<br>

**5. 입력과 출력의 예시를 함께 제시**<br>

**6. 모델에게 명확한 역할 부여**<br>
 - 너는 천재 개발자야, 너는 경험 많은 법률 자문가야<br>

**7. 피해야 할 조건, 표현, 스타일 등을 명시**<br>
 - 반말은 사용하지 마, arrow function 사용하지 마<br>

**8. 복잡한 요청은 단계별로 나눠서 지시**<br>
 - 깃에 레파지토리 생성, 프로젝트 소스 업로드, readme file 작성 순서대로 실행해줘<br>

**9. AI 출력을 검토하고 프롬프트를 점진적으로 개선**<br>

**10. 추론 단계를 직접 명시** <br>

핵심 💥 AI가 프롬프트에 담긴 모든 정보를 다 이해할 것이라는 기대는 하지 말자.

### 추론 유도 CoT
추론 유도 (CoT, Chain-of-Thought) 란 AI가 추론 과정을 단계별로 설명하도록 유도하거나, 추론 단계를 직접 명시하는 방법입니다. 이 방법을 사용하여 오류가 발생하면 LLM이 직접 생각하여 고치고, 또 예방할 수 있도록 만들 수 있습니다. 요즘 LLM끼리 대화를 시키고 토론을 시키는 주제를 많이 봤었는데 참 신기한 일이 많아요. 추론 유도는 다음 블로그에서 더 자세히 알아보겠습니다.

### AI의 기억 한계

LLM은 긴 프롬프트에서 중간 부분의 정보를 잊어버리거나 생략하고, 처음과 끝 부분만 잘 기억하는 경향이 있습니다. 그래서 시스템 프롬프트를 제일 처음에, 유저 프롬프트가 제일 끝에 위치합니다! 이는 사람이 긴 강의에서 처음과 결론만 선명하게 기억하는 것과 유사합니다. ~~사람도 아니면서...~~ 

그래서 프롬프트를 작성할 땐 **최대한 짧고 간결하게**, **중요한 내용은 프롬프트의 처음과 끝에 배치**

기억하자!


### 영문 프롬프트

대부분의 LLM의 학습 데이터가 영어로 이루어져있고 영어로 동작합니다. 그래서 프롬프트를 영어로 작성했을 때의 장점이 많습니다.

  * **토큰 사용량 감소 및 비용 절감**<br>
  영어 학습 데이터가 압도적으로 많아 동일한 의미를 표현할 때 한글보다 훨씬 적은 토큰을 사용합니다.
  * **처리 속도 향상**<br>
  토큰 수가 적으면 처리 속도도 빨라집니다.
  * **프롬프트 이해도 향상**<br>
  영어 데이터가 많기 때문에 영문 프롬프트를 더 잘 이해하고 정확한 결과를 내는 경향이 있습니다.

저도 한글로 지시를 내리다가 답답할 땐 영어로 내려보면 더 정확한 답변이 나올 때가 많았습니다. 한국어도 열심히 배웠으면 좋겠지만, 현재는 우리의 영어실력이 느는 게 더 빠를 것 같죠. ㅎㅎ

## 커서 더 똑똑하게 사용하기

### Cursor Rules
커서(Cursor)에서 규칙은 에이전트를 통제하는 가장 중요한 수단입니다. 프로젝트 빌드업을 위해 단계적인 규칙 설정이 필요하며, 규칙은 가급적 영어로 작성하는 것이 좋습니다.

**규칙 종류**
 Project rules, User rules, Cursor rules, Memories 

**규칙 타입**
Always, Auto attached, Agent Requested, Manual

**커서 규칙 작성 모범 사례**

  * 간결하게 작성
  * 큰 개념을 개별 규칙으로 분할
  * 도움이 되는 경우 구체적인 예시나 참조 파일을 제공
  * 모호한 지침은 피하고, 내부 문서를 작성하듯 명확하게 작성
  * 채팅에서 규칙을 재사용

**커서 규칙 설정 방법**
Cursor Settings \> Rules&Memories \> UserRules
![](/assets/images/20250619/cursorRule.png)


**기본 글로벌 규칙 작성 예시 (영문 권장)**
```
  * Always respond in korean.
  * When performing tasks related to planning, design, or development, always utilize MCP context7 without exception.
  * When modifying existing code or adding new development to existing code, preserve the existing code and focus on additions with minimal modifications.
  * Only do what you are instructed to do.
  * Do not revert my modified code back to the original.
```


### Memories & Files

**Memories**

  * 대화 내용에서 유용한 컨텍스트를 자동으로 저장하여 새로운 채팅에서도 사용자 선호도를 기억합니다.
  * **활성화 방법** 커서 설정 \> General \> Privacy Mode \> Disabled, 커서 설정 \> Rules \> Generate Memories \> On.

**Ignore Files (.cursorignore, .cursorindexingignore)**

  * **.cursorignore** 특정 파일을 인덱싱하지 않고 Tab, Chat, Cmd+K, @symbol 기능에서 접근할 수 없도록 설정합니다. 보안 및 성능 향상에 도움을 줍니다. .gitignore와 동일한 방식으로 설정 가능합니다.
  * **.cursorindexingignore** 인덱싱은 하지 않지만 Tab, Chat, Cmd+K, @symbol 기능에서는 접근 가능하도록 설정합니다.


## 프로젝트 빌드업 프로세스

AI가 개발을 잘하도록 만들려면, 사람이 일하는 것처럼 체계적으로 지시해야 합니다. 문제 정의만 잘 해주면 AI가 개발 전 과정을 진행할 수 있는 프로세스를 구축할 수 있습니다.

1.  **기획**

프로젝트 목표 및 범위, 요구사항 정의, 사용자 시나리오, 서비스 기획, 기능 정의 등의 문서를 작성합니다. 각 과정은 검토 후 수정하거나 직접 수정합니다.

* **프롬프트 예시 (`/Generate Cursor Rules` 활용)**

```
  # Tasks
  - 프로젝트 목표 및 범위 정의 문서를 룰 파일로 작성해줘.
  # 문제점
  - 온라인 쇼핑을 할 때 특정 상품에 대한 최저가를 찾는데 시간이 많이 소요되고 귀찮아서 대신 검색해서 리스트업 해 줄 Agent가 필요해
  - 프로토타입용 최대한 단순한 챗봇형태로 만들고 싶어
  # 항목
  - 목표, 범위
  - 항목외에는 작성하지마
```

*이미 기획 및 설계 문서가 있다면 해당 내용을 기반으로 요약 및 정리하도록 지시할 수 있습니다. 모든 과정은 직접 검수해야 합니다.*

2.  **설계** 

기획 규칙을 참고하여 기술 스택 선정, 기술 설계서, DB 모델링, 화면 설계서, API 명세서 등을 작성합니다.

* **사용자 시나리오 MDC 예시**

  ```
  # Task
  - 사용자 시나리오 룰 파일 작성해줘.
  - 룰 파일에 mermaid로 다이어그램 그려줘
  # 참고할 파일들
  - @목표및범위.mdc
  # 항목
  - 페르소나, 정황, 사용자의 목표, 사용자의 작업 및 행동, 시나리오, 기대효과 또는 결과
  - 항목외에는 작성하지마
  ```

* **요구사항 정의서(PRD) MDC 예시**

  ```
  # Task
  - PRD 룰 파일 작성해줘
  # 요구사항
  - 프로토타입용 단순한 챗봇형태
  - 챗봇 응답은 실시간 스트리밍 SSE 방식
  - 멀티턴으로 과거 대화 내용 참조하여 응답
  - langgraph의 pre-built된 react agent 사용
  - 상품명을 자유롭게 입력
  - 직접 쇼핑몰에서 스크래핑하지 말고 MCP 인터넷 검색툴들 연동해서 검색
  - 검색된 상품들의 가격이나 할인 배송 정보 구매링크 등 가져와서 리스트업해서 보여주기
  - agent와 파싱은 LLM gemini-2.5-flash-preview-05-20 로 개발
  - 1회성이라서 데이터베이스는 따로 사용할 필요 없어
  - 인증 연결안할거고 보안도 신경쓰지마
  # 참고할 파일들
  - @목표및범위.mdc, @사용자시나리오.mdc
  # 항목
  - 항목외에는 작성하지마
  - 제품 개요 및 목적, 핵심 고객/사용자, 문제 정의, 비즈니스 목표 및 성공 지표, 요구사항(기능/비기능), 유저 흐름 및 시나리오, 제약사항 및 전제조건, 성공의 정의(KPI)
  ```

* **기술 스택 문서 MDC 예시**

  ```
  # Task
  - 기술 스택 룰파일 작성해줘
  # 기술 스택
  - language: python 3.11
  - backend(api): fastapi
  - frontend: streamlit
  ## Agent
  - langgraph, langsmith
  - mcp tools: Naver search, Exa search
  - llm: gemini-2.5-flash-preview-05-20
  - memory: 랭그래프 로컬 메모리 모듈
  # 참고할 파일들
  - @prd.mdc
  # 항목
  - 프론트엔드, 백엔드, Agent
  - 항목외에는 작성하지마
  ```

* **시스템 아키텍처 MDC 예시**

  ```
  # Task
  - 시스템 아키텍처 그려줘
  - 다이어그램은 룰 파일에 mermaid로 그려줘
  # 참고할 파일들
  - @prd.mdc, @기술스택.mdc
  # 항목
  - 아키텍처 구성요소, 계층 구조, 모듈화 및 컴포넌트, 데이터 흐름, API 및 인터페이스, 시스템 외부 환경과의 관계
  - 항목외에는 작성하지마
  ```

* **UX 와이어프레임 MD 작성 예시**

  ```
  # Task
  - UX 와이어프레임 md 파일 docs폴더에 작성해줘
  - 와이어 프레임은 SVG 파일로 따로 만들어서 룰 파일에 삽입시켜줘
  - 웹 ux만 그려줘
  # 참고할 파일들
  - @prd.mdc, @시스템아키텍쳐.mdc
  # 항목
  - ux 와이어 프레임
  - 항목외에는 작성하지마
  ```

* **API 명세서 MDC 예시**

  ```
  # Task
  - 심플하게 api 명세서 룰 작성해줘
  - 테이블로 작성해줘
  - 인증, 권한, 보안 등 내용은 빼줘
  # 참고할 파일들
  - @prd.mdc, @시스템아키텍쳐.mdc
  # 항목
  - 엔드포인트 URL, HTTP 메서드, 요청 파라미터, 요청 예시, 응답구조
  - 항목외에는 작성하지마
  ```

* **폴더 구조 작성 예시**

  ```
  # Task
  - 프로젝트 폴더 구조를 룰 파일에 폴더트리 형태로 작성해줘
  - 심플하게 백엔드, 프론트엔드 나눠서 Layered Structure 스타일로 설계해줘
  - 각 폴더에 __init__.py 파일 추가하고
  - 가장 기본적인 스켈레톤 코드 파일 목록만 나열해줘
  # 참고할 파일들
  - @prd.mdc, @api.mdc
  # 항목
  - 폴더 트리
  - 항목외에는 작성하지마
  ```

3.  **Task 정의** 

설계 규칙을 참고하여 Task 정의, 우선순위, 의존성 분석 등을 수행합니다. 업무 분담 및 AI에게 효율적으로 작업을 지시하는 가장 중요한 단계입니다.

* **태스크 정의 MDC 예시**
  ```
  # Task
  - 개발 task를 정의해줘
  - 테이블 형태로 작성하고 해당 테이블 채팅화면에도 그려줘
  - 태스크를 큰 단위로 정의해줘
  # 참고할 파일들
  - @prd.mdc, @api.mdc, @system-architecture.mdc, @tech-stack.mdc
  # 항목
  - task id, title, description, status, dependencies, priority, details, test_strategy
  - 항목외에는 작성하지마
  ```

AI를 더 잘 알기위해 공부하고, 더욱 사용을 하다보면 명확한 지시와 체계적인 접근이 얼마나 중요한지 생각하게 됩니다. 오늘 알아본 프롬프트 엔지니어링 원칙과 Cursor의 기능을 보기만 하지 말고 활용하고 직접 사용해보며 AI와의 생산적인 협업을 시작해보세요!

## **3. 게으르지 말고, 계획하자**

요즘 ChatGPT, Cursor, LangChain 같은 도구들을 활용한 AI 코딩이 점점 보편화되고 있습니다. 특히 실무에서 빠르고 정확하게 일을 처리하고 싶은 개발자라면, AI를 더욱 현명하게 사용해봅시다.
 AI는 “잘 쓰면 날개, 못 쓰면 시간 도둑”입니다.

[원티드 바이브코딩 Week 2-1 강의]에서 배운 **AI와 함께하는 실전 개발 전략**을 정리했습니다.


1. 계획 시키기

“계획을 시켜라. 벌어질 참사를 미리 막자.”

AI는 생각보다 똑똑하지만, 맥락이 부족하면 황당한 코드를 내놓기도 합니다. 그래서 다음 3가지를 꼭 명시해야 합니다.

* **코딩할 파일**
* **사용할 기술 스택**
* **개발 순서**

> ex) "skeleton-development-plan.mdc를 기준으로 순서대로 진행해줘"

계획만 잘 세워도 절반은 먹고 들어갑니다. AI에게도 사람처럼 생각할 여지를 주세요. 그것이 CoT(Chain of Thought) 기법입니다.

2. 리뷰는 생명

AI가 쓴 코드는 늘 그럴싸해 보입니다. 하지만 실제로는 빈껍데기인경우가 많습니다. 절대 맹신하지 말 것

* 동작을 안 해
* 구조가 이상해
* 일관성이 없어
* "할루시네이션"에 빠져 자꾸 거짓말해

**그래서 ‼️** 리뷰는 필수입니다.

* 구조와 큰 로직은 이해하고 있기
* 반복 요청 시 결과가 바뀌는 것도 고려하기

내가 개발팀에 팀장이 되었다고 생각하고 큰 틀과 흐름은 다 파악하고 있어야합니다.


3. 인덱싱

AI가 자꾸 예전 코드로 돌아간다면?

👉 `@Recent Changes` 명령어를 쓰거나
👉 `Cursor 설정 > Indexing & Docs > Sync` 를 눌러주세요.

> “내가 수정한 걸 무시하고 다시 지 코드로 돌아감”… 분노할 필요 없습니다. Sync를 안 해서 그렇습니다 😅

4. 한번에 짧게, 많이 시켜라

AI에게 일을 시킬 때는 "계획된 다중 작업"이 가장 효율적입니다.

* 한 번에 많은 작업을 시키면 **비용 절감** 가능
* 다만 작업이 길면 **길을 잃을 위험**이 있으므로 순차 실행 / 적절한 분할이 필요

> 작업 분할 기준은 “기능 단위 + 테스트 단위”로 잡는 게 좋습니다.

5. 정확하게 명시

“여기만 수정해줘”는 프로젝트 전체를 망가뜨릴 수 있는 매우 강력한 명령입니다.

* 파일명, 함수명, 라인 범위까지 구체적으로 지정
* 가능하면 예시까지 알려 주기

6. AI 능력을 파악하기

바이브 코딩을 하다 보면, 다음과 같은 경향을 알 수 있습니다.

| 잘하는 일       | 못하는 일            |
| ----------- | ---------------- |
| 반복적 패턴 생성   | 로직 설계 (처음부터 끝까지) |
| 테스트 코드 자동화  | 프로젝트 구조 잡기       |
| 주석/문서 자동 생성 | 리팩토링 대규모로 맡기기    |

따라서 **TDD, Clean Architecture**를 미리 도입해두고, 리팩토링 없이 처음부터 잘 짜는 게 좋습니다.

> “리팩토링할 코드를 애초에 안 짜면 된다.”

7. 버전 관리는 나중에

개발 초기에는 패키지 버전을 고정하지 않는 게 유리합니다. AI가 자꾸 버전 충돌을 내기 때문에, 완성 후 버전을 고정하고 `requirements.txt`를 정리하는 게 실전적인 방법입니다.



## Agent란?

Agent는 단순히 명령을 수행하는 수준이 아닙니다.

* **기억하고**
* **판단하고**
* **계획하며**
* **필요한 도구를 사용해**
* **결과를 스스로 만들어내는 AI**

> AI가 단순한 툴이 아니라, **작업 동료**가 되는 순간입니다.

LangChain, LangGraph, React-Agent 등 다양한 툴이 등장하고 있으며, 앞으로 실무에 더 깊게 녹아들 것으로 보입니다.


## 개발은 결국 사람이

AI는 매우 강력한 도구지만, 주도권은 인간에게 있습니다.

* **게으르지 말고**
* **계획적으로 일 시키고**
* **결과를 리뷰하고**
* **필요하면 직접 손으로 고치고**
* **반영도 정확하게 Sync 시키고**

이것이야말로 실무에 통하는 진짜 “바이브 코딩”입니다.

## **4. 바이브 코딩으로 현업 고도화**


AI와의 협업이 현실이 된 지금, 진짜 실무에서는 “어떻게 하면 AI를 잘 써먹을 수 있을까?”가 핵심 질문입니다. 이번 **바이브코딩 Week 2-2 강의**에서는 AI와 함께 협업하고, 프로젝트를 한 단계 더 고도화하는 실질적인 전략과 실습을 배웠습니다.

1. 협업의 출발은 기획

바이브 코딩은 단순한 프롬프트 작성이 아닙니다. 협업의 시작은 “명확한 문제 정의와 요구사항”입니다.

* 서비스 기획서
* 기능 정의서
* 화면 설계서
* API 명세서
* 기술 스택 결정
* DB 모델링

이런 문서들이 있어야 AI도 **무엇을 할지, 어떻게 할지**를 정확히 이해합니다. AI와의 협업도 결국은 사람이 얼마나 준비됐느냐에 달려 있습니다.

2. AI와 협업하려면, 일 잘 시켜야 한다

> “일을 시킬 줄 모르면, AI는 오히려 방해꾼이 된다.”

효율적인 협업을 위한 워크플로우가 있습니다.

1. **태스크 정의 및 분할**
2. 테스트 코드(TDD) 먼저
3. 소스 파일 작성
4. Lint 검사 (옵션)
5. 테스트 실행
6. 코드 리뷰 & PR
7. 반복적 디버깅 및 리팩토링

Cursor 환경에서 GitHub MCP, PR 자동화, 라벨링, 자동 커멘트 등은 **협업 자동화의 핵심 도구**입니다.

3. “시키지도 않은 짓”을 막는 법


| 문제                | 해결책                     |
| ----------------- | ----------------------- |
| 기존 코드 망가뜨림        | 수정할 범위와 내용을 명확히 지정      |
| 코드 구조를 엉망으로 만듦    | 단순하고 직관적인 구현만 요청        |
| 쓸데없는 로직 추가        | "필수 기능만 최소한으로 추가"라고 강조  |
| 직접 수정했더니 원래대로 돌아감 | Cursor 설정에서 인덱싱 수동 Sync |

---

4. 멀티턴, 스트리밍, MCP — 실무 기능 고도화

이제 단순 API 호출을 넘어서, **사용자 경험 중심 기능**도 AI가 직접 구현하게 할 수 있습니다.

## 멀티턴

**Multi-turn**

* 사용자 대화를 기억하며 문맥을 유지
* LangGraph의 InMemoryStore 활용

> ex)
>
> * 유저: 아이폰 128GB
> * 유저: 256GB도 확인해줘 → 이 맥락을 기억해서 이어서 검색

## 스트리밍 응답

**Streaming Response**

* FastAPI + SSE로 실시간 응답 구현
* 프론트에서 **청크 단위**로 결과 확인 가능
* 더 빠르고 자연스러운 사용자 경험 제공

## MCP

**Multi-Client Plugin**

웹 검색, 가격 비교, 쇼핑 정보 검색 등 외부 API도 AI가 MCP 방식으로 자동 활용

* Naver Search MCP
* Exa Search MCP
* LangChain 웹검색 툴 수정 가능
* `.env`에 MCP URL만 추가하면 연결 완료

5. 멀티 에이전트 구조

> “AI가 AI에게 일을 시키는 시대”

## Multi-Agent 시스템 구조

1. **Supervisor Agent** 전체 태스크 관리, 하위 에이전트 호출
2. **Product Attribute Survey Agent** 상품 정보 수집
3. **Price Search Agent** 가격 정보 검색 (React Agent 방식)

이런 구조는 **의사결정 + 병렬 처리 + 피드백 루프**까지 가능하게 하며, 복잡한 워크플로우도 자동으로 처리할 수 있게 해줍니다.


## 실무에서 필요한 고도화 기능

| 기능                      | 설명                                        |
| ----------------------- | ----------------------------------------- |
| **Prompt Chaining**     | 복잡한 문제를 자연스럽게 분해해서 해결                     |
| **Parallelization**     | LLM을 동시에 여러 개 호출해서 속도 향상                  |
| **Routing**             | 입력에 따라 적절한 에이전트로 자동 분기                    |
| **Orchestrator-Worker** | LLM이 스스로 작업을 분할하고 관리                      |
| **Evaluator-Optimizer** | 하나의 LLM이 작업하고, 다른 LLM이 평가하고 개선            |
| **Memory**              | 대화 또는 프로젝트 맥락을 기억 (short-term, long-term) |


## 배포 & 통합 테스트까지

* **AWS EC2**: 1년 무료 티어로 백엔드 배포
* **GCP Cloud Run**: 일정 트래픽 이하 평생 무료
* **Playwright MCP**: 통합 테스트 자동화까지 가능

> AI가 개발하고, 테스트하고, 배포하는 시대입니다. 이제 개발자는 **감독과 판단의 역할**이 더 중요해지고 있어요.


## AI는 동료이자 도구다

바이브 코딩의 진짜 핵심은, AI를 **효율적이고 스마트하게 일 시키는 능력**입니다. 결국 AI는 개발자의 실행력을 높여주는 **우수한 동료**이자 **자동화 도구**입니다.

* **계획하고**
* **정확하게 시키고**
* **명확하게 수정하고**
* **끝까지 테스트하고 리뷰하자**

그렇게 AI와 협업하는 시대가 이미 시작됐습니다.
